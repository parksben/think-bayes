{"version":3,"sources":["../../esm/Cdf/index.js"],"names":["Cdf","xs","ps","name","map","x","i","p","push","term","another","copy","math","add","factor","mult","index","sub","RangeError","length","value","div","Math","random","n","Array","fill","oldProb","total","items","percentage","prob","interval","multiplier","UnimplementedMethodException","k","cdf","DictWrapper"],"mappings":"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","sourcesContent":["import DictWrapper from '../DictWrapper';\nimport { makePmfFromCdf } from '../convertors';\nimport math from '../math';\nimport { UnimplementedMethodException } from '../utils';\nimport { bisect } from '../algorithm/bisect';\n\n/**\n * Represents a cumulative distribution function.\n * @param {array} xs sequence of values\n * @param {array} ps sequence of probabilities\n * @param {string} name string used as a graph label\n */\nexport default class Cdf extends DictWrapper {\n  constructor(xs, ps, name) {\n    super(null, name);\n    this.xs = xs || [];\n    this.ps = ps || [];\n  }\n\n  /**\n   * Represents a cumulative distribution function.\n   * @param {string} name string name for the new cdf\n   * @returns new cdf\n   */\n  copy(name) {\n    return new Cdf(this.xs, this.ps, name || this.name);\n  }\n\n  /**\n   * Makes a Pmf.\n   * @param {string} name string name for the new pmf\n   * @returns new pmf\n   */\n  makePmf(name) {\n    return makePmfFromCdf(this, name);\n  }\n\n  /**\n   * Returns a sorted list of values.\n   * @returns array of values\n   */\n  values() {\n    return this.xs;\n  }\n\n  /**\n   * Returns a sorted sequence of [value, probability] pairs.\n   * @returns array of [value, probability] pairs\n   */\n  items() {\n    return this.xs.map((x, i) => [x, this.ps[i]]);\n  }\n\n  /**\n   * Add an (x, p) pair to the end of this CDF.\n   * Note: this us normally used to build a CDF from scratch, not\n   * to modify existing CDFs.  It is up to the caller to make sure\n   * that the result is a legal CDF.\n   * @param {any} x number value or case name\n   * @param {number} p number freq or prob\n   */\n  append(x, p) {\n    this.xs.push(x);\n    this.ps.push(p);\n  }\n\n  /**\n   * Adds a term to the xs.\n   * @param {number} term how much to add\n   * @returns another cdf\n   */\n  shift(term) {\n    const another = this.copy();\n    another.xs = this.xs.map(x => math.add(x, term || 0));\n    return another;\n  }\n\n  /**\n   * Multiplies the xs by a factor.\n   * @param {*} factor what to multiply by\n   * @returns another cdf\n   */\n  scale(factor) {\n    const another = this.copy();\n    another.xs = this.xs.map(x => math.mult(x, factor || 1));\n    return another;\n  }\n\n  /**\n   * Returns CDF(x), the probability that corresponds to value x.\n   * @param {number} x number\n   * @returns float probability\n   */\n  prob(x) {\n    if (!x || x < this.xs[0]) return 0.0;\n    const index = bisect(this.xs, x);\n    const p = this.ps[math.sub(index, 1)];\n    return p;\n  }\n\n  /**\n   * Returns InverseCDF(p), the value that corresponds to probability p.\n   * @param {number} p number in the range [0, 1]\n   * @returns number value\n   */\n  value(p) {\n    if (!p || p < 0 || p > 1)\n      throw new RangeError('Probability p must be in range [0, 1]');\n    if (p === 0) return this.xs[0];\n    if (p === 1) return this.xs[math.sub(this.xs.length, 1)];\n\n    const index = bisect(this.ps, p);\n    if (p === this.ps[math.sub(index, 1)]) {\n      return this.xs[math.sub(index, 1)];\n    }\n    return this.xs[index];\n  }\n\n  /**\n   * Returns the value that corresponds to percentile p.\n   * @param {number} p number in the range [0, 100]\n   * @returns number value\n   */\n  percentile(p) {\n    return this.value(math.div(p, 100));\n  }\n\n  /**\n   * Chooses a random value from this distribution.\n   * @returns number value\n   */\n  random() {\n    return this.value(Math.random());\n  }\n\n  /**\n   * Generates a random sample from this distribution.\n   * @param {number} n int length of the sample\n   * @returns array of random values\n   */\n  sample(n) {\n    return new Array(n).fill(0).map(() => this.random());\n  }\n\n  /**\n   * Computes the mean of a CDF.\n   * @returns float mean\n   */\n  mean() {\n    let oldProb = 0;\n    let total = 0;\n\n    const items = this.xs.map((x, i) => [x, this.ps[i]]);\n    for (let [x, p] of items) {\n      // total += (p - oldProb) * x\n      total = math.add(total, math.mult(math.sub(p, oldProb), x));\n      oldProb = p;\n    }\n    return total;\n  }\n\n  /**\n   * Computes the central credible interval.\n   * If percentage=90, computes the 90% CI.\n   * @param {number} percentage float between 0 and 100\n   * @returns sequence of two floats, low and high\n   */\n  credibleInterval(percentage = 90) {\n    // prob = (1 - percentage / 100.0) / 2\n    const prob = math.div(math.sub(1, math.div(percentage, 100)), 2);\n    const interval = [this.value(prob), this.value(math.sub(1, prob))];\n    return interval;\n  }\n\n  /**\n   * An entry is added to the cdf only if the percentile differs\n   * from the previous value in a significant digit, where the number\n   * of significant digits is determined by multiplier.\n   * The default is 1000, which keeps log10(1000) = 3 significant digits.\n   * @param {number} multiplier\n   */\n  _round(multiplier = 1000) {\n    // TODO: write this method\n    throw new UnimplementedMethodException(\n      'This method has not been implemented by the author for the time being. Please pay attention to the changelog of this project.'\n    );\n  }\n\n  /**\n   * Generates a sequence of points suitable for plotting.\n   * An empirical CDF is a step function; linear interpolation can be misleading.\n   * @returns array of points\n   */\n  render() {\n    const xs = [this.xs[0]];\n    const ps = [0];\n    for (let [i, p] of this.ps) {\n      xs.push(this.xs[i]);\n      ps.push(p);\n      if (this.xs[math.add(i, 1)]) {\n        xs.push(this.xs[math.add(i, 1)]);\n        ps.push(p);\n      }\n    }\n    return xs.map((x, i) => [x, ps[i]]);\n  }\n\n  /**\n   * Computes the CDF of the maximum of k selections from this dist.\n   * @param {number} k int\n   * @returns new Cdf\n   */\n  max(k) {\n    const cdf = this.copy();\n    cdf.ps = cdf.ps.map(p => p ** k);\n    return cdf;\n  }\n}\n"],"file":"index.js"}