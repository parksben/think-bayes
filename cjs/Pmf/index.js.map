{"version":3,"sources":["../../esm/Pmf/index.js"],"names":["Pmf","x","probDefault","d","get","xs","map","prob","name","t","filter","val","reduce","prev","curr","math","add","fraction","logFlag","ValueError","total","entries","p","set","div","mult","size","target","Math","random","RangeError","mu","miu","mean","variance","sub","maxProb","max","values","find","percentage","cdf","makeCdf","credibleInterval","other","addPmf","e","addConstant","pmf","items","v1","p1","v2","p2","incr","v","k","ps","c","DictWrapper"],"mappings":"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","sourcesContent":["import DictWrapper from '../DictWrapper';\nimport { ValueError } from '../utils';\nimport { makeCdfFromPmf } from '../convertors';\nimport math from '../math';\n\n/**\n * Represents a probability mass function.\n * Values can be any hashable type; probabilities are floating-point.\n * Pmfs are not necessarily normalized.\n * @param {string|array|object} values sequence of values\n * @param {string} name sequence of values\n */\nexport default class Pmf extends DictWrapper {\n  /**\n   * Gets the probability associated with the value x.\n   * @param {any} x number value\n   * @param {number} probDefault value to return if the key is not there\n   * @returns probability\n   */\n  prob(x, probDefault = 0) {\n    return this.d.get(x) || probDefault;\n  }\n\n  /**\n   * Gets probabilities for a sequence of values.\n   * @param {array} xs a sequence of values\n   * @returns array of probabilities\n   */\n  probs(xs) {\n    return xs.map(x => this.prob(x));\n  }\n\n  /**\n   * Makes a cdf.\n   * @param {string} name the name for new cdf\n   * @returns one new cdf\n   */\n  makeCdf(name) {\n    return makeCdfFromPmf(this, name);\n  }\n\n  /**\n   * Calculate the probability while the value is greater than x.\n   * @param {number} x\n   * @returns probability\n   */\n  probGreater(x) {\n    const t = [...this.d]\n      .filter(([val, prob]) => val > x)\n      .map(([val, prob]) => prob);\n    return t.reduce((prev, curr) => math.add(prev, curr));\n  }\n\n  /**\n   * Calculate the probability while the value is less than x.\n   * @param {number} x\n   * @returns probability\n   */\n  probLess(x) {\n    const t = [...this.d]\n      .filter(([val, prob]) => val < x)\n      .map(([val, prob]) => prob);\n    return t.reduce((prev, curr) => math.add(prev, curr));\n  }\n\n  /**\n   * Normalizes this PMF so the sum of all probs is fraction.\n   * @param {number} fraction what the total should be after normalization\n   * @returns the total probability before normalizing\n   */\n  normalize(fraction = 1.0) {\n    if (this.logFlag) throw new ValueError('pmf is under a log transform');\n\n    const total = this.total();\n    if (total === 0.0)\n      throw new ValueError('Normalize: total probability is zero.');\n\n    for (let [x, p] of this.d.entries()) {\n      this.d.set(x, math.div(math.mult(p, fraction), total));\n    }\n\n    return total;\n  }\n\n  /**\n   * Chooses a random element from this PMF.\n   * @returns float value from the pmf\n   */\n  random() {\n    if (this.d.size === 0) throw new ValueError('pmf contains no values.');\n\n    const target = Math.random();\n    let total = 0;\n    for (let [x, p] of this.d.entries()) {\n      total = math.add(total, p);\n      if (total >= target) return x;\n    }\n\n    throw new RangeError(\n      `Value not found, no one value in this pmf matches the random target '${target}'`\n    );\n  }\n\n  /**\n   * Computes the mean of a PMF.\n   * @returns float mean\n   */\n  mean() {\n    let mu = 0;\n    for (let [x, p] of this.d.entries()) {\n      mu = math.add(mu, math.mult(p, x));\n    }\n    return mu;\n  }\n\n  /**\n   * Computes the variance of a PMF.\n   * @param {number} miu the point around which the variance is computed; if omitted, computes the mean\n   * @returns float variance\n   */\n  var(miu) {\n    const mu = miu || this.mean();\n    let variance = 0;\n    for (let [x, p] of this.d.entries()) {\n      // variance += p * (x - mu) ** 2\n      variance = math.add(variance, math.mult(p, math.sub(x, mu) ** 2));\n    }\n    return variance;\n  }\n\n  /**\n   * Returns the value with the highest probability.\n   * @returns float probability\n   */\n  maximumLikelihood() {\n    const maxProb = Math.max(...this.d.values());\n    const [val] = [...this.d].find(([x, p]) => p === maxProb);\n    return val;\n  }\n\n  /**\n   * Computes the central credible interval.\n   * If percentage=90, computes the 90% CI.\n   * @param {number} percentage float between 0 and 100\n   * @returns sequence of two floats, low and high\n   */\n  credibleInterval(percentage = 90) {\n    const cdf = this.makeCdf();\n    return cdf.credibleInterval(percentage);\n  }\n\n  /**\n   * Computes the Pmf of the sum of values drawn from self and other.\n   * @param {number|pmf} other another pmf or a number\n   * @returns new pmf\n   */\n  add(other) {\n    try {\n      return this.addPmf(other);\n    } catch (e) {\n      return this.addConstant(other);\n    }\n  }\n\n  /**\n   * Computes the Pmf of the sum of values drawn from self and other.\n   * @param {pmf} other another pmf\n   * @returns new pmf\n   */\n  addPmf(other) {\n    const pmf = new Pmf();\n    for (let [v1, p1] of this.items()) {\n      for (let [v2, p2] of other.items()) {\n        pmf.incr(math.add(v1, v2), math.mult(p1, p2));\n      }\n    }\n    return pmf;\n  }\n\n  /**\n   * Computes the Pmf of the sum a constant and  values from self.\n   * @param {number} other a number\n   * @returns new pmf\n   */\n  addConstant(other) {\n    const pmf = new Pmf();\n    for (let [v, p] of this.items()) {\n      pmf.set(math.add(v, other), p);\n    }\n    return pmf;\n  }\n\n  /**\n   * Computes the Pmf of the diff of values drawn from self and other.\n   * @param {pmf} other another pmf\n   * @returns new pmf\n   */\n  sub(other) {\n    const pmf = new Pmf();\n    for (let [v1, p1] of this.items()) {\n      for (let [v2, p2] of other.items()) {\n        pmf.incr(math.sub(v1, v2), math.mult(p1, p2));\n      }\n    }\n    return pmf;\n  }\n\n  /**\n   * Computes the CDF of the maximum of k selections from this dist.\n   * @param {number} k int\n   * @returns new cdf\n   */\n  max(k) {\n    const cdf = this.makeCdf();\n    cdf.ps = cdf.ps.map(c => c ** k);\n    return cdf;\n  }\n}\n"],"file":"index.js"}