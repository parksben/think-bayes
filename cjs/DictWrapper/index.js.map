{"version":3,"sources":["../../esm/DictWrapper/index.js"],"names":["DictWrapper","values","name","d","Map","logFlag","initMethods","initPmf","bind","initSequence","initMapping","initFailure","method","e","size","normalize","value","set","entries","prob","items","ValueError","keys","has","get","x","term","itemProb","math","add","factor","mult","result","delete","ReferenceError","reduce","prev","p","Math","max","newObj","another","copy","clear","val","m","maxLike","log","div","remove","exp","sub","isObject","o","isMap","TypeError","Object","sort","a","b","compare","rows","render"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;IAKqBA,W;;;AACnB,uBAAYC,MAAZ,EAAoBC,IAApB,EAA0B;AAAA;;AACxB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,CAAL,GAAS,IAAIC,GAAJ,EAAT,CAFwB,CAIxB;;AACA,SAAKC,OAAL,GAAe,KAAf;AAEA,QAAI,CAACJ,MAAL,EAAa;AAEb,QAAMK,WAAW,GAAG,CAClB,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CADkB,EAElB,KAAKC,YAAL,CAAkBD,IAAlB,CAAuB,IAAvB,CAFkB,EAGlB,KAAKE,WAAL,CAAiBF,IAAjB,CAAsB,IAAtB,CAHkB,EAIlB,KAAKG,WAAL,CAAiBH,IAAjB,CAAsB,IAAtB,CAJkB,CAApB;;AAOA,oCAAmBF,WAAnB,kCAAgC;AAA3B,UAAIM,MAAM,mBAAV;;AACH,UAAI;AACFA,QAAAA,MAAM,CAACX,MAAD,CAAN;AACA;AACD,OAHD,CAGE,OAAOY,CAAP,EAAU;AACV;AACD;AACF;;AAED,QAAI,KAAKV,CAAL,CAAOW,IAAP,GAAc,CAAlB,EAAqB;AACnB,WAAKC,SAAL;AACD;AACF;AAED;;;;;;;;iCAIad,M,EAAQ;AAAA;AAAA;AAAA;;AAAA;AACnB,6BAAkBA,MAAlB,8HAA0B;AAAA,cAAjBe,KAAiB;AACxB,eAAKC,GAAL,CAASD,KAAT,EAAgB,CAAhB;AACD;AAHkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIpB;AAED;;;;;;;gCAIYf,M,EAAQ;AAAA;AAAA;AAAA;;AAAA;AAClB,8BAA0BA,MAAM,CAACiB,OAAP,EAA1B,mIAA4C;AAAA;AAAA,cAAlCF,KAAkC;AAAA,cAA3BG,IAA2B;;AAC1C,eAAKF,GAAL,CAASD,KAAT,EAAgBG,IAAhB;AACD;AAHiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAInB;AAED;;;;;;;4BAIQlB,M,EAAQ;AAAA;AAAA;AAAA;;AAAA;AACd,8BAA0BA,MAAM,CAACmB,KAAP,EAA1B,mIAA0C;AAAA;AAAA,cAAhCJ,KAAgC;AAAA,cAAzBG,IAAyB;;AACxC,eAAKF,GAAL,CAASD,KAAT,EAAgBG,IAAhB;AACD;AAHa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIf;AAED;;;;;;gCAGYlB,M,EAAQ;AAClB,YAAM,IAAIoB,iBAAJ,CAAe,4CAAf,CAAN;AACD;;;;AAMD;;;;;;6BAMS;AACP,gCAAW,KAAKlB,CAAL,CAAOmB,IAAP,EAAX;AACD;AAED;;;;;;4BAGQ;AACN,gCAAW,KAAKnB,CAAhB;AACD;;;wBAEGa,K,EAAO;AACT,aAAO,KAAKb,CAAL,CAAOoB,GAAP,CAAWP,KAAX,CAAP;AACD;;;wBAEGA,K,EAAO;AACT,aAAO,KAAKb,CAAL,CAAOqB,GAAP,CAAWR,KAAX,CAAP;AACD;AAED;;;;;;;;wBAKIA,K,EAAOG,I,EAAM;AACf,aAAO,KAAKhB,CAAL,CAAOc,GAAP,CAAWD,KAAX,EAAkBG,IAAlB,CAAP;AACD;AAED;;;;;;;;yBAKKM,C,EAAa;AAAA,UAAVC,IAAU,uEAAH,CAAG;AAChB,UAAMC,QAAQ,GAAG,KAAKxB,CAAL,CAAOqB,GAAP,CAAWC,CAAX,KAAiB,CAAlC;AACA,WAAKtB,CAAL,CAAOc,GAAP,CAAWQ,CAAX,EAAcG,cAAKC,GAAL,CAASF,QAAT,EAAmBD,IAAnB,CAAd;AACD;AAED;;;;;;;;yBAKKD,C,EAAe;AAAA,UAAZK,MAAY,uEAAH,CAAG;AAClB,UAAMH,QAAQ,GAAG,KAAKxB,CAAL,CAAOqB,GAAP,CAAWC,CAAX,KAAiB,CAAlC;AACA,WAAKtB,CAAL,CAAOc,GAAP,CAAWQ,CAAX,EAAcG,cAAKG,IAAL,CAAUJ,QAAV,EAAoBG,MAApB,CAAd;AACD;AAED;;;;;;;;2BAKOd,K,EAAO;AACZ,UAAMgB,MAAM,GAAG,KAAK7B,CAAL,CAAO8B,MAAP,CAAcjB,KAAd,CAAf;;AACA,UAAI,CAACgB,MAAL,EAAa;AACX,cAAM,IAAIE,cAAJ,qEACyDlB,KADzD,uBAAN;AAGD;;AACD,aAAOgB,MAAP;AACD;AAED;;;;;;4BAGQ;AACN,aAAO,mBAAI,KAAK7B,CAAT,EAAYgC,MAAZ,CAAmB,UAACC,IAAD;AAAA;AAAA,YAAQX,CAAR;AAAA,YAAWY,CAAX;;AAAA,eAAkBT,cAAKC,GAAL,CAASO,IAAT,EAAeC,CAAf,CAAlB;AAAA,OAAnB,EAAwD,CAAxD,CAAP;AACD;AAED;;;;;;8BAGU;AACR,aAAOC,IAAI,CAACC,GAAL,OAAAD,IAAI,qBAAQ,KAAKnC,CAAL,CAAOF,MAAP,EAAR,EAAX;AACD;AAED;;;;;;;;;;yBAOKC,I,EAAM;AACT,UAAMsC,MAAM,GAAG,yBAAa,IAAb,CAAf;AACAA,MAAAA,MAAM,CAACrC,CAAP,GAAW,yBAAa,KAAKA,CAAlB,CAAX;AACAqC,MAAAA,MAAM,CAACtC,IAAP,GAAcA,IAAI,IAAI,KAAKA,IAA3B;AACA,aAAOsC,MAAP;AACD;AAED;;;;;;;;0BAKMV,M,EAAQ;AACZ,UAAMW,OAAO,GAAG,KAAKC,IAAL,EAAhB;AACAD,MAAAA,OAAO,CAACtC,CAAR,CAAUwC,KAAV;AAFY;AAAA;AAAA;;AAAA;AAGZ,8BAAwB,KAAKxC,CAAL,CAAOe,OAAP,EAAxB,mIAA0C;AAAA;AAAA,cAAhC0B,GAAgC;AAAA,cAA3BzB,IAA2B;;AACxCsB,UAAAA,OAAO,CAACxB,GAAR,CAAYW,cAAKG,IAAL,CAAUa,GAAV,EAAed,MAAf,CAAZ,EAAoCX,IAApC;AACD;AALW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMZ,aAAOsB,OAAP;AACD;AAED;;;;;;;;;wBAMII,C,EAAG;AACL,UAAI,KAAKxC,OAAT,EACE,MAAM,IAAIgB,iBAAJ,CAAe,wCAAf,CAAN;AAEF,WAAKhB,OAAL,GAAe,IAAf;AACA,UAAI,CAACwC,CAAL,EAAQA,CAAC,GAAG,KAAKC,OAAL,EAAJ;AALH;AAAA;AAAA;;AAAA;AAOL,8BAAmB,KAAK3C,CAAL,CAAOe,OAAP,EAAnB,mIAAqC;AAAA;AAAA,cAA3BO,CAA2B;AAAA,cAAxBY,CAAwB;;AACnC,cAAIA,CAAJ,EAAO;AACL,iBAAKpB,GAAL,CAASQ,CAAT,EAAYa,IAAI,CAACS,GAAL,CAASnB,cAAKoB,GAAL,CAASX,CAAT,EAAYQ,CAAZ,CAAT,CAAZ;AACD,WAFD,MAEO;AACL,iBAAKI,MAAL,CAAYxB,CAAZ;AACD;AACF;AAbI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcN;AAED;;;;;;;;wBAKIoB,C,EAAG;AACL,UAAI,CAAC,KAAKxC,OAAV,EACE,MAAM,IAAIgB,iBAAJ,CAAe,oCAAf,CAAN;AAEF,UAAI,CAACwB,CAAL,EAAQA,CAAC,GAAG,KAAKC,OAAL,EAAJ;AAJH;AAAA;AAAA;;AAAA;AAML,8BAAmB,KAAK3C,CAAL,CAAOe,OAAP,EAAnB,mIAAqC;AAAA;AAAA,cAA3BO,CAA2B;AAAA,cAAxBY,CAAwB;;AACnC,eAAKpB,GAAL,CAASQ,CAAT,EAAYa,IAAI,CAACY,GAAL,CAAStB,cAAKuB,GAAL,CAASd,CAAT,EAAYQ,CAAZ,CAAT,CAAZ;AACD;AARI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASN;AAED;;;;;;8BAGU;AACR,aAAO,KAAK1C,CAAZ;AACD;AAED;;;;;;;4BAIQA,C,EAAG;AACT,UAAMiD,QAAQ,GAAG,SAAXA,QAAW,CAAAC,CAAC;AAAA,eAAI,QAAOA,CAAP,MAAa,QAAjB;AAAA,OAAlB;;AACA,UAAMC,KAAK,GAAG,SAARA,KAAQ,CAAAD,CAAC;AAAA,eAAIA,CAAC,YAAYjD,GAAjB;AAAA,OAAf;;AAEA,UAAI,CAACgD,QAAQ,CAACjD,CAAD,CAAb,EACE,MAAM,IAAIoD,SAAJ,CAAc,oDAAd,CAAN;AAEF,WAAKpD,CAAL,GAASiD,QAAQ,CAACjD,CAAD,CAAR,IAAe,CAACmD,KAAK,CAACnD,CAAD,CAArB,GAA2B,IAAIC,GAAJ,CAAQoD,MAAM,CAACtC,OAAP,CAAef,CAAf,CAAR,CAA3B,GAAwDA,CAAjE;AACD;AAED;;;;;;;6BAIS;AACP,aAAO,mBAAI,KAAKA,CAAT,EAAYsD,IAAZ,CAAiB;AAAA;AAAA,YAAEC,CAAF;;AAAA;AAAA,YAAOC,CAAP;;AAAA,eAAc/B,cAAKgC,OAAL,CAAaF,CAAb,EAAgBC,CAAhB,CAAd;AAAA,OAAjB,CAAP;AACD;AAED;;;;;;;4BAIQ;AACN,6BAAW;AAAEE,QAAAA,IAAI,EAAE,KAAKC,MAAL;AAAR,OAAX;AACD;;;wBA5LU;AACT,aAAO,KAAK3D,CAAL,CAAOW,IAAd;AACD","sourcesContent":["import { ValueError, shallowClone, printTable } from '../utils';\nimport math from '../math';\n\n/**\n * An base class for generation an object contains a dictionary.\n * @param {string|array|object} values sequence of values\n * @param {string} name sequence of values\n */\nexport default class DictWrapper {\n  constructor(values, name) {\n    this.name = name;\n    this.d = new Map();\n\n    // flag whether the distribution is under a log transform\n    this.logFlag = false;\n\n    if (!values) return;\n\n    const initMethods = [\n      this.initPmf.bind(this),\n      this.initSequence.bind(this),\n      this.initMapping.bind(this),\n      this.initFailure.bind(this),\n    ];\n\n    for (let method of initMethods) {\n      try {\n        method(values);\n        break;\n      } catch (e) {\n        continue;\n      }\n    }\n\n    if (this.d.size > 0) {\n      this.normalize();\n    }\n  }\n\n  /**\n   * Initializes with a sequence of equally-likely values.\n   * @param {array} values sequence of values\n   */\n  initSequence(values) {\n    for (let value of values) {\n      this.set(value, 1);\n    }\n  }\n\n  /**\n   * Initializes with a map from value to probability.\n   * @param {map} values map from value to probability\n   */\n  initMapping(values) {\n    for (let [value, prob] of values.entries()) {\n      this.set(value, prob);\n    }\n  }\n\n  /**\n   * Initializes with a Pmf.\n   * @param {pmf} values Pmf object\n   */\n  initPmf(values) {\n    for (let [value, prob] of values.items()) {\n      this.set(value, prob);\n    }\n  }\n\n  /**\n   * Throw an error.\n   */\n  initFailure(values) {\n    throw new ValueError('None of the initialization methods worked.');\n  }\n\n  get size() {\n    return this.d.size;\n  }\n\n  /**\n   * Gets an unsorted sequence of values.\n   * Note: One source of confusion is that the keys of this\n   * dictionary are the values of the Hist/Pmf, and the\n   * values of the dictionary are frequencies/probabilities.\n   */\n  values() {\n    return [...this.d.keys()];\n  }\n\n  /**\n   * Gets an unsorted sequence of (value, freq/prob) pairs.\n   */\n  items() {\n    return [...this.d];\n  }\n\n  has(value) {\n    return this.d.has(value);\n  }\n\n  get(value) {\n    return this.d.get(value);\n  }\n\n  /**\n   * Sets the freq/prob associated with the value x.\n   * @param {any} value number value or case name\n   * @param {number} prob number freq or prob\n   */\n  set(value, prob) {\n    return this.d.set(value, prob);\n  }\n\n  /**\n   * Increments the freq/prob associated with the value x.\n   * @param {any} x number value or case name\n   * @param {number} term how much to increment by\n   */\n  incr(x, term = 1) {\n    const itemProb = this.d.get(x) || 0;\n    this.d.set(x, math.add(itemProb, term));\n  }\n\n  /**\n   * Scales the freq/prob associated with the value x.\n   * @param {any} x number value or case name\n   * @param {number} factor how much to multiply by\n   */\n  mult(x, factor = 1) {\n    const itemProb = this.d.get(x) || 0;\n    this.d.set(x, math.mult(itemProb, factor));\n  }\n\n  /**\n   * Removes a value.\n   * Throws an exception if the value is not there.\n   * @param {any} value value to remove\n   */\n  remove(value) {\n    const result = this.d.delete(value);\n    if (!result) {\n      throw new ReferenceError(\n        `Data deletion failed, because there is no item-key named '${value}' in the dataset.`\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Returns the total of the frequencies/probabilities in the map.\n   */\n  total() {\n    return [...this.d].reduce((prev, [x, p]) => math.add(prev, p), 0);\n  }\n\n  /**\n   * Returns the largest frequency/probability in the map.\n   */\n  maxLike() {\n    return Math.max(...this.d.values());\n  }\n\n  /**\n   * Returns a copy.\n   * Make a shallow copy of d. If you want a deep copy of d,\n   * use one method to deep clone the whole object.\n   * @param {string} name string name for the new Hist\n   * @returns new object\n   */\n  copy(name) {\n    const newObj = shallowClone(this);\n    newObj.d = shallowClone(this.d);\n    newObj.name = name || this.name;\n    return newObj;\n  }\n\n  /**\n   * Multiplies the values by a factor.\n   * @param {number} factor what to multiply by\n   * @returns new object\n   */\n  scale(factor) {\n    const another = this.copy();\n    another.d.clear();\n    for (let [val, prob] of this.d.entries()) {\n      another.set(math.mult(val, factor), prob);\n    }\n    return another;\n  }\n\n  /**\n   * Log transforms the probabilities.\n   * Removes values with probability 0.\n   * Normalizes so that the largest logprob is 0.\n   * @param {number} m how much to shift the ps before exponentiating\n   */\n  log(m) {\n    if (this.logFlag)\n      throw new ValueError('Pmf/Hist already under a log transform');\n\n    this.logFlag = true;\n    if (!m) m = this.maxLike();\n\n    for (let [x, p] of this.d.entries()) {\n      if (p) {\n        this.set(x, Math.log(math.div(p, m)));\n      } else {\n        this.remove(x);\n      }\n    }\n  }\n\n  /**\n   * Exponentiates the probabilities.\n   * If m is un-exist, normalizes so that the largest prob is 1.\n   * @param {number} m how much to shift the ps before exponentiating\n   */\n  exp(m) {\n    if (!this.logFlag)\n      throw new ValueError('Pmf/Hist not under a log transform');\n\n    if (!m) m = this.maxLike();\n\n    for (let [x, p] of this.d.entries()) {\n      this.set(x, Math.exp(math.sub(p, m)));\n    }\n  }\n\n  /**\n   * Gets the dictionary.\n   */\n  getDict() {\n    return this.d;\n  }\n\n  /**\n   * Sets the dictionary.\n   * @param {map|object} d\n   */\n  setDict(d) {\n    const isObject = o => typeof o === 'object';\n    const isMap = o => o instanceof Map;\n\n    if (!isObject(d))\n      throw new TypeError('Value of the data set should be one map or object.');\n\n    this.d = isObject(d) && !isMap(d) ? new Map(Object.entries(d)) : d;\n  }\n\n  /**\n   * Generates a sequence of points suitable for plotting.\n   * @returns array of [sorted value sequence, freq/prob sequence]\n   */\n  render() {\n    return [...this.d].sort(([a], [b]) => math.compare(a, b));\n  }\n\n  /**\n   * Prints the values and freqs/probs in ascending order.\n   * @param indent\n   */\n  print() {\n    printTable({ rows: this.render() });\n  }\n}\n"],"file":"index.js"}