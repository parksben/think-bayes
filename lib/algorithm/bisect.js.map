{"version":3,"sources":["../../src/algorithm/bisect.js"],"names":["bisect","xs","x","s","e","Array","isArray","TypeError","start","end","math","sub","length","add","mid","parseInt","div"],"mappings":";;;;;;;;;;;AAAA;;;;AAEA;;;;;;AAMO,IAAMA,MAAM,GAAG,SAATA,MAAS,CAACC,EAAD,EAAKC,CAAL,EAAQC,CAAR,EAAWC,CAAX,EAAiB;AACrC,MAAI,CAACH,EAAD,IAAO,CAACI,KAAK,CAACC,OAAN,CAAcL,EAAd,CAAZ,EACE,MAAM,IAAIM,SAAJ,CACJ,gEADI,CAAN;AAGF,MAAI,CAACL,CAAL,EAAQ,MAAM,IAAIK,SAAJ,CAAc,gDAAd,CAAN;AAER,MAAMC,KAAK,GAAGL,CAAC,IAAI,CAAnB;;AACA,MAAMM,GAAG,GAAGL,CAAC,IAAIM,cAAKC,GAAL,CAASV,EAAE,CAACW,MAAZ,EAAoB,CAApB,CAAjB,CARqC,CAUrC;;;AACA,MAAIV,CAAC,GAAGD,EAAE,CAACO,KAAD,CAAV,EAAmB,OAAOA,KAAP;AACnB,MAAIN,CAAC,KAAKD,EAAE,CAACO,KAAD,CAAZ,EAAqB,OAAOE,cAAKG,GAAL,CAASL,KAAT,EAAgB,CAAhB,CAAP;AACrB,MAAIN,CAAC,IAAID,EAAE,CAACQ,GAAD,CAAX,EAAkB,OAAOC,cAAKG,GAAL,CAASJ,GAAT,EAAc,CAAd,CAAP,CAbmB,CAerC;AACA;;AACA,MAAMK,GAAG,GAAGC,QAAQ,CAACL,cAAKG,GAAL,CAASL,KAAT,EAAgBE,cAAKM,GAAL,CAASN,cAAKC,GAAL,CAASF,GAAT,EAAcD,KAAd,CAAT,EAA+B,CAA/B,CAAhB,CAAD,EAAqD,EAArD,CAApB;AACA,MAAIN,CAAC,KAAKD,EAAE,CAACa,GAAD,CAAZ,EAAmB,OAAOJ,cAAKG,GAAL,CAASC,GAAT,EAAc,CAAd,CAAP;AACnB,SAAOZ,CAAC,GAAGD,EAAE,CAACa,GAAD,CAAN,GACHd,MAAM,CAACC,EAAD,EAAKC,CAAL,EAAQQ,cAAKG,GAAL,CAASC,GAAT,EAAc,CAAd,CAAR,EAA0BL,GAA1B,CADH,GAEHT,MAAM,CAACC,EAAD,EAAKC,CAAL,EAAQM,KAAR,EAAeE,cAAKC,GAAL,CAASG,GAAT,EAAc,CAAd,CAAf,CAFV;AAGD,CAtBM","sourcesContent":["import math from '../math';\n\n/**\n * Calculate the position where a new element should be\n * inserted in an ordered sequence by using the bisection method.\n * @param {array} xs Given ordered sequence\n * @param {number} x Number to be inserted\n */\nexport const bisect = (xs, x, s, e) => {\n  if (!xs || !Array.isArray(xs))\n    throw new TypeError(\n      'Value of the first argument must be a sorted array of numbers.'\n    );\n  if (!x) throw new TypeError('Value of the second argument must be a number.');\n\n  const start = s || 0;\n  const end = e || math.sub(xs.length, 1);\n\n  // (-Infinity, start] or [end, Infinity)\n  if (x < xs[start]) return start;\n  if (x === xs[start]) return math.add(start, 1);\n  if (x >= xs[end]) return math.add(end, 1);\n\n  // (start, end)\n  // mid = parseInt(start + (end - start) / 2, 10)\n  const mid = parseInt(math.add(start, math.div(math.sub(end, start), 2)), 10);\n  if (x === xs[mid]) return math.add(mid, 1);\n  return x > xs[mid]\n    ? bisect(xs, x, math.add(mid, 1), end)\n    : bisect(xs, x, start, math.sub(mid, 1));\n};\n"],"file":"bisect.js"}